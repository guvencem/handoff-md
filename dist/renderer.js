"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderHandoff = renderHandoff;
const assembler_1 = require("./assembler");
const structure_1 = require("./analyzers/structure");
function renderHandoff(ctx) {
    const budget = (0, assembler_1.getBudget)(ctx.format);
    const sections = [];
    // Header
    const lastCommit = ctx.git?.recentCommits[0];
    let header = `# HANDOFF — ${ctx.projectName}\n`;
    header += `> Generated by \`handoff\` at ${ctx.timestamp}\n`;
    if (ctx.git) {
        header += `> Branch: \`${ctx.git.currentBranch}\``;
        if (lastCommit) {
            header += ` | Last commit: ${lastCommit.hash} ${lastCommit.message}`;
        }
        header += '\n';
    }
    sections.push((0, assembler_1.truncateToTokenBudget)(header, budget.header));
    // Stack
    let stackSection = `## Stack\n`;
    const frameworkStr = ctx.stack.framework !== 'unknown' ? ctx.stack.framework + ' + ' : '';
    const langStr = ctx.stack.language !== 'unknown' ? ctx.stack.language : '';
    const pmStr = ctx.stack.packageManager !== 'unknown' ? ctx.stack.packageManager : '';
    stackSection += [frameworkStr + langStr, pmStr].filter(Boolean).join(' | ') + '\n';
    const extras = [];
    if (ctx.stack.orm)
        extras.push(`ORM: ${ctx.stack.orm}`);
    if (ctx.stack.database)
        extras.push(`DB: ${ctx.stack.database}`);
    if (ctx.stack.auth)
        extras.push(`Auth: ${ctx.stack.auth}`);
    if (ctx.stack.deploy)
        extras.push(`Deploy: ${ctx.stack.deploy}`);
    if (ctx.stack.testing)
        extras.push(`Test: ${ctx.stack.testing}`);
    if (ctx.stack.linter)
        extras.push(`Lint: ${ctx.stack.linter}`);
    if (extras.length > 0) {
        stackSection += extras.join(' | ') + '\n';
    }
    sections.push((0, assembler_1.truncateToTokenBudget)(stackSection, budget.stack));
    // Structure
    if (ctx.structure.tree.length > 0) {
        let structSection = `## Structure\n\`\`\`\n`;
        structSection += (0, structure_1.treeToString)(ctx.structure.tree);
        structSection += `\n\`\`\`\n`;
        if (ctx.structure.entryPoints.length > 0) {
            structSection += `Entry points: ${ctx.structure.entryPoints.join(', ')}\n`;
        }
        sections.push((0, assembler_1.truncateToTokenBudget)(structSection, budget.structure));
    }
    // Conventions
    if (ctx.structure.conventions.length > 0 || ctx.config) {
        let convSection = `## Conventions\n`;
        for (const conv of ctx.structure.conventions) {
            convSection += `- ${conv.category}: ${conv.pattern}\n`;
        }
        if (ctx.config) {
            convSection += `\n### Existing AI Config (from ${ctx.config.configSource})\n`;
            convSection += ctx.config.existingInstructions.join('\n') + '\n';
        }
        sections.push((0, assembler_1.truncateToTokenBudget)(convSection, budget.conventions + (ctx.config ? budget.config : 0)));
    }
    // Recent Activity
    if (ctx.git && ctx.git.recentCommits.length > 0) {
        const maxCommits = ctx.format === 'compact' ? 5 : ctx.format === 'standard' ? 10 : 15;
        let activitySection = `## Recent Activity\n`;
        for (const commit of ctx.git.recentCommits.slice(0, maxCommits)) {
            activitySection += `- \`${commit.hash}\` ${commit.message}`;
            if (commit.date)
                activitySection += ` (${commit.date})`;
            activitySection += '\n';
        }
        sections.push((0, assembler_1.truncateToTokenBudget)(activitySection, budget.activity));
    }
    // Current State
    if (ctx.git) {
        let stateSection = `## Current State\n`;
        // Analyze what's being worked on
        if (ctx.git.uncommittedChanges.length > 0) {
            stateSection += `**Uncommitted changes (${ctx.git.uncommittedChanges.length} files):**\n`;
            const maxChanges = ctx.format === 'compact' ? 10 : 20;
            for (const change of ctx.git.uncommittedChanges.slice(0, maxChanges)) {
                stateSection += `- ${change}\n`;
            }
            if (ctx.git.uncommittedChanges.length > maxChanges) {
                stateSection += `- ... and ${ctx.git.uncommittedChanges.length - maxChanges} more\n`;
            }
        }
        else {
            stateSection += `Working tree is clean.\n`;
        }
        // Active branches
        if (ctx.git.activeBranches.length > 1) {
            stateSection += `\n**Active branches:**\n`;
            for (const branch of ctx.git.activeBranches.slice(0, 5)) {
                const current = branch.name === ctx.git.currentBranch ? ' ← current' : '';
                stateSection += `- \`${branch.name}\` (${branch.relativeDate})${current}\n`;
            }
        }
        // Conflicts
        if (ctx.git.conflictFiles.length > 0) {
            stateSection += `\n**⚠ Merge conflicts:**\n`;
            for (const file of ctx.git.conflictFiles) {
                stateSection += `- ${file}\n`;
            }
        }
        sections.push((0, assembler_1.truncateToTokenBudget)(stateSection, budget.state));
    }
    // Known Issues
    if (ctx.structure.todos.length > 0) {
        let issuesSection = `## Known Issues\n`;
        for (const todo of ctx.structure.todos) {
            issuesSection += `- **${todo.type}** \`${todo.file}:${todo.line}\` ${todo.text}\n`;
        }
        sections.push((0, assembler_1.truncateToTokenBudget)(issuesSection, budget.issues));
    }
    // Environment
    if (ctx.structure.envVars.length > 0) {
        let envSection = `## Environment\n`;
        envSection += `Required env vars: \`${ctx.structure.envVars.join('`, `')}\`\n`;
        sections.push((0, assembler_1.truncateToTokenBudget)(envSection, budget.env));
    }
    return sections.join('\n');
}
//# sourceMappingURL=renderer.js.map